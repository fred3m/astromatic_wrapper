# Copyright 2015 Fred Moolekamp
# BSD 3-clause license
"""
Pipeline for Astromatic-Wrapper
"""
import os
import numpy as np
import subprocess
import copy
import logging
from six import string_types
import datetime
from astropy.io import fits

from astromatic import api
from astromatic.utils import utils

logger = logging.getLogger('astromatic.pipeline')

class PipelineError(utils.AstromaticError):
    """
    Class for errors when running an AstrOmatic Pipeline
    """
    pass

class Pipeline:
    def __init__(self, temp_path, build_paths={}, log_path=None, steps=[], nextid=0,
            pipeline_name=None, create_paths=False, **kwargs):
        """
        Parameters
        ----------
        temp_path: str
            path to store temporary files
        build_paths: dict (optional)
            paths to astromatic builds
                * Not needed if the codes were installed system wide (ex. 'sex' runs SExtractor)
                * Keys are commands for astromatic packages ('sex', 'scamp', 'swarp', 'psfex')
                * Values are the paths to the build for the given key
        log_path: str (optional)
            path to save astromatic xml log files
        steps: list of `astromatic.pipeline.PipelineStep` (optional)
            If the user already as a list of steps to run they can be 
            set when the pipeline is initialized
        nexid: int (optional)
            Next number to use for a pipeline step id. The default is ``0``
        kwargs: dict
            Additional keyword arguments that might be used in a custom pipeline.
        """
        self.temp_path = temp_path
        self.build_paths = build_paths
        self.create_paths = create_paths
        
        # Set additional keyword arguements
        for key, value in kwargs.items():
            setattr(self, key, value)
        
        # If the temp path doesn't exist, give the user the option to create it
        utils.check_path(self.temp_path, create_paths)
        
        # If the user specified a set of steps for the pipeline, add them here
        self.steps = steps
        self.next_id = 0
        
        # Set the time that the pipeline was created and create a directory
        # for log files
        self.name = pipeline_name
        self.run_date = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        self.log_path = os.path.join(self.log_path, self.run_date)
        if pipeline_name is not None:
            self.log_path += '_'+pipeline_name
        utils.create_paths([self.log_path])
        logger.info(self.log_path)
    
    def run_sex(self, step_id, files, api_kwargs={}, frames=None):
        """
        Run SExtractor with a specified set of parameters.
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        files: dict
            Dict of filenames for fits files to use in sextractor. Possible keys are:
                * image: filename of the fits image (required)
                * dqmask: filename of a bad mixel mask for the given image (optional)
                * wtmap: filename of a weight map for the given image (optional)
        kwargs: dict
            Keyword arguements to pass to ``atrotoyz.Astromatic.run`` or
            ``astrotoyz.Astromatic.run_sex_frames``
        frames: str (optional)
            Only run sextractor on a specific set of frames. This should either be an 
            integer string, or a string of csv's
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SExtractor'
        if 'cmd' not in api_kwargs and 'SExtractor' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SExtractor']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'CATALOG_NAME' not in api_kwargs['config']:
            api_kwargs['config']['CATALOG_NAME'] = files['image'].replace('.fits', '.cat')
        if 'FLAG_IMAGE' not in api_kwargs['config'] and 'dqmask' in files:
            api_kwargs['config']['FLAG_IMAGE'] = files['dqmask']
        if 'WEIGHT_IMAGE' not in api_kwargs['config'] and 'wtmap' in files:
            api_kwargs['config']['WEIGHT_IMAGE'] = files['wtmap']
        if 'WRITE_XML' not in api_kwargs['config']:
            api_kwargs['config']['WRITE_XML'] = 'Y'
        if 'XML_NAME' not in api_kwargs['config']:
            api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                '{0}.sex.log.xml'.format(step_id))
        sex = api.Astromatic(**api_kwargs)
        if frames is None:
            result = sex.run(files['image'])
        else:
            result = sex.run_frames(files['image'], 'SExtractor', frames, False)
        return result
    
    def run_scamp(self, step_id, catalogs, api_kwargs={}, save_catalog=None):
        """
        Run SCAMP with a specified set of parameters
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        catalogs: list
            List of catalog names used to generate astrometric solution
        api_kwargs: dict
            Dictionary of keyword arguments used to run SCAMP
        save_catalog: str (optional)
            If ``save_catalog`` is specified, the reference catalog used to generate the
            solution will be save to the path ``save_catalog``.
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SCAMP'
        if 'cmd' not in api_kwargs and 'SCAMP' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SCAMP']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if save_catalog is not None:
            api_kwargs['config']['SAVE_REFCATALOG'] = 'Y'
            api_kwargs['config']['REFOUT_CATPATH'] = save_catalog
        if 'WRITE_XML' not in api_kwargs['config']:
            api_kwargs['config']['WRITE_XML'] = 'Y'
        if 'XML_NAME' not in api_kwargs['config']:
            api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                '{0}.scamp.log.xml'.format(step_id))
        scamp = api.Astromatic(**api_kwargs)
        result = scamp.run(catalogs)
        return result
    
    def run_swarp(self, step_id, filenames, api_kwargs, frames=None):
        """
        Run SWARP with a specified set of parameters
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        filenames: list
            List of filenames that are stacked together
        api_kwargs: dict
            Keyword arguments used to run SWARP
        frames: list (optional)
            Subset of frames to stack. Default value is ``None``, which stacks all of the
            image frames for each file
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'SWarp'
        if 'cmd' not in api_kwargs and 'SWARP' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['SWARP']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'RESAMPLE_DIR' not in api_kwargs['config']:
            api_kwargs['config']['RESAMPLE_DIR'] = api_kwargs['temp_path']
        if 'IMAGEOUT_NAME' not in api_kwargs['config']:
            raise PipelineError('Must include a name for the new stacked image')
        if 'WRITE_XML' not in api_kwargs['config']:
            api_kwargs['config']['WRITE_XML'] = 'Y'
        if 'XML_NAME' not in api_kwargs['config']:
            api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                '{0}.scamp.log.xml'.format(step_id))
        swarp = api.Astromatic(**api_kwargs)
        if frames is None:
            result = swarp.run(filenames)
        else:
            result = swarp.run_frames(filenames, 'SWarp', frames, False)
        return result
    
    def run_psfex(self, step_id, catalogs, api_kwargs={}):
        """
        Run PSFEx with a specified set of parameters.
        
        Parameters
        ----------
        step_id: str
            Unique identifier for the current step in the pipeline
        catalogs: str or list
            catalog filename (or list of catalog filenames) to use
        api_kwargs: dict
            Keyword arguements to pass to PSFEx
        
        Returns
        -------
        result: dict
            Result of the astromatic code execution. This will minimally contain a ``status``
            key, that indicates ``success`` or ``error``. Additional keys:
            - error_msg: str
                If there is an error and the user is storing the output or exporting XML metadata,
                ``error_msg`` will contain the error message generated by the code
            - output: str
                If ``store_output==True`` the output of the program execution is
                stored in the ``output`` value.
            - warnings: str
                If the WRITE_XML parameter is ``True`` then a table of warnings detected
                in the code is returned
        """
        if 'code' not in api_kwargs:
            api_kwargs['code'] = 'PSFEx'
        if 'cmd' not in api_kwargs and 'PSFEx' in self.build_paths:
            api_kwargs['cmd'] = self.build_paths['PSFEx']
        if 'temp_path' not in api_kwargs:
            api_kwargs['temp_path'] = self.temp_path
        if 'config' not in api_kwargs:
            api_kwargs['config'] = {}
        if 'WRITE_XML' not in api_kwargs['config']:
            api_kwargs['config']['WRITE_XML'] = 'Y'
        if 'XML_NAME' not in api_kwargs['config']:
            api_kwargs['config']['XML_NAME'] = os.path.join(self.log_path, 
                '{0}.psfex.log.xml'.format(step_id))
        psfex = api.Astromatic(**api_kwargs)
        result = psfex.run(catalogs)
        return result
     
    def add_step(self, func, tags, **kwargs):
        """
        Add a new `PipelineStep` to the pipeline
        
        Parameters
        ----------
        func: function or string
            If ``func`` is a string this should be the name of an astromatic code, otherwise
            ``func`` is a function to be run in the pipeline. All functions must return
            a dictionary with at a minimum a ``status`` key whose value is either
            ``success`` or ``error``.
        tags: list
            A list of tags used to identify the step. When running the pipeline the user
            can specify a set of conditions that will filter which steps are run (or not run)
            based on a set of specified tags
        kwargs: dict
            Keyword arguments passed to the ``func`` when the pipeline is run
        """
        if isinstance(func, string_types):
            if func in api.codes:
                if func == 'SExtractor':
                    func = self.run_sex
                elif func == 'SCAMP':
                    func = self.run_scamp
                elif func == 'PSFEx':
                    func = self.run_psfex
                elif func == 'SWARP':
                    func = self.run_swarp
                else:
                    raise PipelineError("You must either pass a function for the pipeline "
                        "to run or the name of an astromatic code")
            else:
                raise PipelineError("You must either pass a function for the pipeline "
                    "to run or the name of an astromatic code")
        step_id = self.next_id
        self.next_id += 1
        self.steps.append(PipelineStep(
            func,
            step_id,
            tags,
            kwargs
        ))
            
    def run(self, run_tags=[], ignore_tags=[], pipeline_steps=None):
        """
        Run the pipeline given a list of PipelineSteps
        
        Parameters
        ----------
        run_tags: list
            Run all steps that have a tag listed in ``run_tags`` and not in ``ignore_tags``.
            If ``len(run_tags)==0`` then all of the steps are run that are not listed 
            in ignore tags.
        ignore_tags: list
            Ignore all steps that contain one of the tags in ``ignore_tags``.
        pipeline_steps: list of `PipelineStep` (optional)
            Instead of running the steps associated with a pipeline, the user can specify
            a set of steps to run. This can be useful if (for example) mulitple criteria
            are used to select steps to run and the user wants to perform these cuts in
            some other function to generate the necessary steps to run.
        logfile: filename or file object
            Keeps track of which steps have been run. Each time a step is run it is
            logged in the log file so that if there is an error that causes the pipeline
            to stop, the user can pick up where he/she left off.
        """
        if pipeline_steps is None:
            pipeline_steps = self.steps
        
        steps = [step for step in pipeline_steps if
            (len(run_tags) == 0 or any([tag in run_tags for tag in self.tags])) and
            not any([tag in ignore_tags for tag in self.tags])]
        
        all_warnings = None
        for step in steps:
            result = step.func(step.ste_id, **step.func_kwargs)
            if 'warnings' in result:
                from astropy.table import vstack
                warnings = result['warnings']
                warnings['filename'] = result.meta['filename']
                warnings['step'] = step.step_id
                if all_warnings is None:
                    all_warnings = warnings
                else:
                    all_warnings = vstack([all_warnings, warnings])
            if result['status'] == 'error':
                result = {
                    'status': 'error',
                    'function_result': result,
                    'warnings': all_warnings,
                    'log': log
                }
                return result
        
        result = {
            'status': 'success',
            'warnings': all_warnings
        }
        return result

class PipelineStep:
    """
    A single step in the pipeline. This takes a function and a set of tags and kwargs
    associated with it and stores them in the pipeline.
    """
    def __init__(self, func, step_id, tags=[], func_kwargs={}):
        """
        Initialize a PipelineStep object
        
        Parameters
        ----------
        func: function
            The function to be run. All functions must return a dictionary with at a 
            minimum a ``status`` key whose value is either ``success`` or ``error``.
        id: str
            Unique identifier for the step
        tags: list
            A list of tags used to identify the step. When running the pipeline the user
            can specify a set of conditions that will filter which steps are run (or not run)
            based on a set of specified tags
        func_kwargs: dict
            Keyword arguments passed to the ``func`` when the pipeline is run
        """
        self.func = func
        self.tags = tags
        self.step_id = step_id
        self.func_kwargs = func_kwargs